import sys
#不用第一个位置留空，我自己的
def fixDown(a, k, n):  # 自顶向下堆化，从k开始堆化
    N = n
    while 2 * k +1<= N:#0-12，1-34，所以2k+1
        if k==0:
            j=1
        else:
            j = 2 * k+1
        if j < N and a[j] < a[j +1]:  # 选出左右孩子节点中更大的那个
            j += 1
        if a[k] < a[j]:
            a[k], a[j] = a[j], a[k]
            k = j
        else:
            break


def heapSort(l):
    n = len(l)
    adjust=n-1
    for i in range(adjust// 2, -1, -1):#必须要从叶节点往上循环排
        fixDown(l, i, len(l)-1)
    while n > 0:
        l[0], l[n-1] = l[n-1], l[0]
        n25=n-2#已经换到最后的不纳入重新堆整理，当作没有
        fixDown(l, 0, n25)#其他的初始之后已经排序好了，只有变动的节点树才需要排序
        n -= 1
    return l

l=list(map(int,sys.stdin.readline().split()))
#l = [-99, 26, 5, 77, 1, 61, 11, 59, 15, 48, 19,1]  # 第一个元素也用，占位
res = heapSort(l)
print(res)
